## 虚拟DOM 和 真实DOM

#### 虚拟DOM 优点

+ 减少DOM操作

  + 减少操作次数

    将需要操作的记下来，统一操作

  + 减少操作范围

    使用diff算法进行范围确认

+ 跨平台渲染

  虚拟DOM本质就是一个树结构，其DOM的标签、属性、方法、参数、子节点都是通过key-value的形式保存，所以可以转变成任何平台对应的节点

#### 虚拟DOM缺点

需要额外创建函数(vue的h函数)，但可通过JSX来简化

会造成严重依赖打包工具

### 虚拟DOM 和 真实DOM对比

1. 就操作DOM而言，虚拟DOM 慢于 真实DOM

   一个是直接操作DOM，一个是控制DOM操作DOM

2. 就浏览器渲染而言，由于虚拟DOM能减少DOM的操作次数，从而减少渲染时间

   即，单次DOM渲染时间相同时，谁渲染次数少谁耗时短

3. 当节点在一定范围内时，虚拟DOM总体具有优势，

   当节点数超过一点限度时，虚拟DOM自身的优化算法会极大的增加开销，并降低其稳定性，此时真实DOM更具有速度优势和稳定性

### DOM diff 大概逻辑

**深度优先，同层比较**

+ **Tree diff**
  + 将新旧两棵树逐层对比，找出哪些节点需要更新
  + 如果节点是组件就看 **Component diff**
  + 如果节点是标签/内容就看 **Element diff**

+ **Component diff**
  + 如果节点是组件，就先看组件类型
  + 类型不同直接替换(删除旧的)
  + 类型相同则只更新属性
  + 然后进入组件做 **Tree diff (递归)**
+ **Element diff**
  + 如果节点是原生标签，则看标签名
  + 标签名不同直接替换，相同则只更新属性
  + 然后进入标签做 **Tree diff (递归)**

#### DOM diff 的缺点

+ 同级节点对比存在bug

  即，在没有`key`进行指示的情况下，是无法精确找到相同节点的

  ```javascript
  [1,2,3]
  [1,3]
  // 在没有key时，此处删除2,
  // 计算机会根据下标对比，会认为
  // 下标1 2->3,下标2 删除
  // 所以，通常不建议使用下标作为 key 值
  ```

  

### vue中的diff

+ vue中的diff执行时刻是组件实例执行其更新函数时，它会对比上次渲染结果oldVnode和新渲染结果newVnode，此过程称为patch

  + 修改一个数据时，由于数据响应式触发了setter
  + setter触发notify
  + notify会尝试将watcher添加到异步更新队列
  + 在每一次事件循环的时候，清空这些队列
  + 清空过程中，所有watcher会执行其更新函数
  + 更新函数执行时，会执行组件的更新函数及组件的渲染函数
  + 此时会重新渲染最新的虚拟DOM
  + 执行更新函数，比较新旧DOM
  + 此时执行diff算法

+ diff过程整体遵循 **深度优先、同层比较** 的策略；

  两个节点之间比较会根据他们是否拥有子节点或者文本节点做不同操作；

  比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；

  借助key通常可以非常精确的找到相同节点，因此整个patch过程非常高兴



+ 必要性

  + lifecycle.js - mountComponent()
  + 一个组件一个watcher，为了精确的知道更新过程中，谁发生了变化

+ 执行方式

  + patch.js - patchVnode()

  + patchVnode是diff发生的地方，整体策略：**深度优先、同层比较**

  + 根据节点对比的不同，使用的策略不同

    | 老的     | 新的     |
    | -------- | -------- |
    | 有子节点 | 有子节点 |
    | 有子节点 | 无子节点 |
    | 无子节点 | 有子节点 |
    | 无子节点 | 无子节点 |

    即，若有子节点则对比子节点；

    ​		若一方有子节点是一种策略；

    ​		若都没有子节点是另一种策略。

+ 高效性

  + patch.js - updateChildren()